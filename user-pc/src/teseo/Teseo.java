/* Teseo 
 * 
 * Created on 15 giugno 2007, 19.21
 * @author Filippo Zanella
 */
package teseo;

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.SplashScreen;
import java.awt.Toolkit;
import java.awt.event.KeyEvent;
import java.io.*;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.math.BigDecimal;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import net.tinyos.message.Message;
import net.tinyos.message.MessageListener;
import net.tinyos.message.MoteIF;
import net.tinyos.packet.*;
import net.tinyos.util.*;

public class Teseo extends javax.swing.JFrame implements MessageListener, Constants
{

    /* -- Parameters that can be set by the developer in initMyComponents () -- */
    private static String version = "2008.12.18.1235";
    private String mapFile;
    private Channel ch;
    /* Connection to the mobile node */
    private MoteIF mote;
    private PhoenixSource phoenix;
    private String  commType;
    private String  commPort;
    private String  commSpeed;
    private boolean isConnectedUser;
    private boolean isConnectedTmote;
    /* Communication with the mobile node */
    private DataMsg dataMsg;
    private PingClientMsg pingClientMsg;
    private boolean atLeastOnePingIsArrived;        // Variable to signal if at least one ping_client_msg is arrived
    private boolean oneMsgIsArrivedAfterEstimation;
    private int curDataMsgId;
    private Node pAnchorNodes;    //private int pAnchorNodesLqi; 
    private Node pMobileNode;
    private Timer timerEstimate;                    // Timer linked to the estimation step
    private EstimateTimerTask timerTaskEstimate;    // Task that calls the routine estimation of class Estimation
    private Estimation estimation;                  
    private VariantExtendedKalmanFilter2D ekf2D;
    private About about;
    private MapPanel mapPanel;
    private long delayTrace;
    private long sampleTrace;
    private long startTime;

    /**
     * Class constructor.
     */
    public Teseo()
    {
        // 1] Init GUI parameters generated by (NetBeans) designer
        initComponents();
        // 2] Init GUI parameters generated by the developer
        initMyComponents();
        printOut("Teseo succesfully started.", false);
    }

    /**
     * Inits GUI parameters generated by the developer and modifies parameters 
     * yet set by (NetBeans) designer.
     */
    private void initMyComponents()
    {
        version = "2008.12.18.1235"; //genVersion();    // !!! Parameter that can be set by the developer 
        printOut("Teseo version: " + version, false);

        /* Init VSI */
        SwingUtilities.updateComponentTreeUI(vsiDialog);
        vsiDialog.setVisible(vsiMenuItem.isSelected());
        //printOut("VSI: " + vsiDialog.isVisible(), false);

        /* Init communication */
        commType = "serial";
        commPort = "/dev/ttyUSB0";
        commSpeed = "tmote";    //115200
        PortText.setText(commType + "@" + commPort + ":" + commSpeed);
        //The user and the mote (?) are disconnected
        isConnectedUser = false;
        isConnectedTmote = false;
        printOut("Communication port: " + commType + "@" + commPort + ":" + commSpeed, false);

        /* Init Trace path */
        delayTrace = AUDIT_TIME * K_TAU_U;        // Start to collect data after 1000 [ms]
        sampleTrace = AUDIT_TIME * K_T_U;      // Sampling every 400 [ms] by default
        delaySpinner.setModel(new SpinnerNumberModel(Long.valueOf(delayTrace), Long.valueOf(AUDIT_TIME), null, Long.valueOf(AUDIT_TIME)));
        sampleSpinner.setModel(new SpinnerNumberModel(Long.valueOf(sampleTrace), Long.valueOf(AUDIT_TIME), null, Long.valueOf(AUDIT_TIME)));
//        tracePanel.setBounds(traceDialog.getBounds());
//        tracePanel.setSize(traceDialog.getWidth()-(int)tracePanel.getLocation().getX(), traceDialog.getHeight()-(int)tracePanel.getLocation().getY());
        printOut("Trace path: " + " delay " + delayTrace + " [ms]" + "\t sampling " + sampleTrace + " [ms] ", false);

        /* Init channel */
        //ch = new Channel(1, 0, -57, 2.12);  // TODO: Info data of fixed nodes in the data_msg
        ch = new Channel(0, -39.77, 3.04);  // TODO: Info data of fixed nodes in the data_msg
        aTextField.setText(Double.toString(ch.getBeta()));
        npTextField.setText(Double.toString(ch.getGamma()));
        printOut("Channel configuration:" + " Beta = " + ch.getBeta() + " [dBm]" + "  Gamma = " + ch.getGamma(), false);
        npTextField.setEnabled(true);
        aTextField.setEnabled(true);

        /* Init mapPanel */
        mapFile = "maps/Floor.map";      // !!! Parameter that can be set by the developer 
        mapPanel = (MapPanel) mapPanelBlank;
        printOut("Map file loaded: " + mapFile, false);
        mapPanel.initEnvironment(mapFile);
        mapPanel.setTraceTracking(traceToggleButton.isSelected());
        traceToggleButton.setSelected(mapPanel.getTraceTracking());
        printOut("Trace tracking: " + mapPanel.getTraceTracking(), false);
        mapPanel.setShowBeacons(beaconsMenuItem.isSelected());
        mapPanel.setShowBeacons(mapPanel.getShowBeacons());
        
        resetEstimation();
    }

    /**
     * Reset the parameters to do a new localization.
     */
    private void resetEstimation()
    {
        /* Init info massages */
        atLeastOnePingIsArrived = false;
        oneMsgIsArrivedAfterEstimation = false;

        /* Init estimation classes */
        estimation = new Estimation();
        ekf2D = new VariantExtendedKalmanFilter2D();

        /* Init info nodes */
        pMobileNode = new Node();
        pAnchorNodes = new Node();
    }

    /**
     * Connects to the specified serial port.
     *
     * @param _source   the address of the serial port
     */
    public void connect(String _source)
    {
        try
        {
            phoenix = BuildSource.makePhoenix(_source, PrintStreamMessenger.err);
            mote = new MoteIF(phoenix);
            mote.registerListener(new DataMsg(), this);
            mote.registerListener(new PingClientMsg(), this);
            mote.registerListener(new MoteCtrlMsg(), this);
            isConnectedUser = true;
            printOut("Connected to " + _source, false);
        } catch (Exception e)
        {
            isConnectedUser = false;
            printOut("Unable to connect (check the port is set correctly)", false);
        }
    }

    /**
     * Disconnects from the specified serial port.
     *
     * @param _source   the address of the serial port
     */
    public void disconnect(String _source)
    {
        mote.deregisterListener(new DataMsg(), this);
        mote.deregisterListener(new PingClientMsg(), this);
        mote.deregisterListener(new MoteCtrlMsg(), this);
        phoenix.shutdown();
        isConnectedUser = false;
        printOut("Disconnected from " + _source, false);
    }

    public void start()
    {
        if (!isConnectedUser && !isConnectedTmote)
        {
            connect(PortText.getText());
            //connect(commType + "@" + commPort + ":" + commSpeed);
        }
        if (isConnectedUser && !isConnectedTmote)
        {
            printOut("Query: START Mobile Node.", false);
            MoteCtrlMsg payload = new MoteCtrlMsg();
            payload.set_work(START);
            try
            {
                mote.send(0, payload);
                isConnectedTmote = true;
            } catch (Exception e)
            {
                isConnectedTmote = false;
                printOut("startButtonActionPerformed(): " + e.toString(), true);
            }
        }
    }

    public void stop()
    {
        if (timerEstimate != null)
        {
            timerEstimate.cancel();
        }
        if (isConnectedUser && isConnectedTmote)
        {
            try
            {
                printOut("Query: STOP Mobile Node.", false);
                MoteCtrlMsg payload = new MoteCtrlMsg();
                payload.set_work(STOP);
                mote.send(0, payload);
                isConnectedTmote = false;
            } catch (IOException e)
            {
                isConnectedTmote = true;
                printOut("stopButtonActionPerformed(): " + e.toString(), true);
            }
        }

        if (isConnectedUser && !isConnectedTmote)
        {
            disconnect(commType + "@" + commPort + ":" + commSpeed);
            resetEstimation();
        }
    }

    synchronized public void messageReceived(int dest, Message msg)
    {
        if (!estimation.isEstimating())         // FIXIT: Can i remove this check?
        {
            if (msg instanceof PingClientMsg)
            {
                pingClientMsg = (PingClientMsg) msg;

                if (!atLeastOnePingIsArrived)
                {
                    printOut("Mobile Node ID " + pingClientMsg.get_mobileNodeID() +
                            "  (power = " + Integer.toString(pingClientMsg.get_power()) + " [dBm]" +
                            ", frequency = " + Integer.toString(pingClientMsg.get_channel()) + "[?]" + ")", false);

                    idTextLabel.setText(Integer.toString(pingClientMsg.get_mobileNodeID()));
                    pMobileNode.setNodeId(pingClientMsg.get_mobileNodeID());
                    atLeastOnePingIsArrived = true;

                    timerEstimate = new Timer();
                    timerTaskEstimate = new EstimateTimerTask();
                    //timerEstimate.schedule(timerTaskEstimate, AUDIT_TIME);     
                    timerEstimate.scheduleAtFixedRate(timerTaskEstimate, 0, AUDIT_TIME);
                    startTime = System.currentTimeMillis();
                }

                long thisStep = pingClientMsg.get_step();
                bcTextLabel.setText(Long.toString(thisStep));
//                printOut("####Ping " + pingClientMsg.get_pkgId() + " received. Step number " + pingClientMsg.get_step() + "####", false);
                
                if (!oneMsgIsArrivedAfterEstimation)
                {
                    mapPanel.CellNodeMapHash.clear();
                }
            }
            else if (msg instanceof DataMsg)
            {
                dataMsg = (DataMsg) msg;

                // If it is the first message after the estimation then I clean the measurements set
                if (!oneMsgIsArrivedAfterEstimation)
                {
                    oneMsgIsArrivedAfterEstimation = true;
                    mapPanel.CellNodeMapHash.clear();
                }

                curDataMsgId = (int) dataMsg.get_fixedNodeID();
                if (mapPanel.NodeMapHash.containsKey(curDataMsgId))
                {
                    if (!mapPanel.CellNodeMapHash.containsKey(curDataMsgId))
                    {
                        // Get the node from the loaded file
                        pAnchorNodes = (Node) mapPanel.NodeMapHash.get(curDataMsgId);

                        // Add a new node in the measurements set of the map
                        mapPanel.CellNodeMapHash.put(curDataMsgId, new Node(pAnchorNodes.getNodeId(), pAnchorNodes.getX(), pAnchorNodes.getY(), pAnchorNodes.getZ()));

                        // Add RSS of the new node in the estimation vector
                        estimation.cellAnchorNodeRssVector.addElement(new Integer(dataMsg.get_rss()));
                        //pAnchorNodesLqi = dataMsg.get_lqi(); 

                        // Add coordinates of the new node in the estimation vector
                        estimation.cellAnchorNodeCoordinatesVector2D.addElement(new Coordinate2D(pAnchorNodes.getX(), pAnchorNodes.getY()));
                    }
                }
                else
                {
                    //printOut("Node " + curDataMsgId + " not present in the map.", false);
                }
            }
        }
    }

    private final class EstimateTimerTask extends TimerTask implements Runnable
    {

        public void run()
        {
            estimation.estimate2D();
        }
    }

    private class Estimation
    {
        // --- Inputs of estimation:
        private Vector<Coordinate2D> cellAnchorNodeCoordinatesVector2D;
        private Vector<Integer> cellAnchorNodeRssVector;
        // --- Outputs of estimation:
        private Coordinate2D mobileNodeCoordinate2D;
        boolean estimating;

        private Estimation()
        {
            cellAnchorNodeCoordinatesVector2D = new Vector<Coordinate2D>();
            cellAnchorNodeRssVector = new Vector<Integer>();
            mobileNodeCoordinate2D = new Coordinate2D(Double.NaN, Double.NaN);

            estimating = false;
        }

        synchronized public void estimate2D()
        {
            estimating = true;

            //long begin = System.currentTimeMillis();

            // 1] Conversion  vector -> array -> double array
            Integer[] cellAnchorNodeRssArray;
            Coordinate2D[] cellAnchorNodeCoordinatesArray2D;
            double[][] cellAnchorNodeRssDoubleArray;
            double[][] cellAnchorNodeCoordinatesDoubleArray2D;

            synchronized (cellAnchorNodeRssVector)
            {
                cellAnchorNodeRssArray = (Integer[]) cellAnchorNodeRssVector.toArray(new Integer[cellAnchorNodeRssVector.size()]);
                cellAnchorNodeRssDoubleArray = new double[cellAnchorNodeRssArray.length][1];
                for (int i = 0; i < cellAnchorNodeRssArray.length; i++)
                {
                    cellAnchorNodeRssDoubleArray[i][0] = cellAnchorNodeRssArray[i];
//                    printOut("ANrss["+ i +"]: " + cellAnchorNodeRssDoubleArray[i][0], false);
                }
            }

            synchronized (cellAnchorNodeCoordinatesVector2D)
            {
                cellAnchorNodeCoordinatesArray2D = (Coordinate2D[]) cellAnchorNodeCoordinatesVector2D.toArray(new Coordinate2D[cellAnchorNodeCoordinatesVector2D.size()]);

                cellAnchorNodeCoordinatesDoubleArray2D = new double[cellAnchorNodeCoordinatesArray2D.length][2];

                for (int i = 0; i < cellAnchorNodeCoordinatesArray2D.length; i++)
                {
                    cellAnchorNodeCoordinatesDoubleArray2D[i][0] = cellAnchorNodeCoordinatesArray2D[i].getX();
                    cellAnchorNodeCoordinatesDoubleArray2D[i][1] = cellAnchorNodeCoordinatesArray2D[i].getY();
                }
            }
            
            // 2] Estimation of planar position of mobile node
            double[][] mobileNodePosition2D = ekf2D.update(cellAnchorNodeRssDoubleArray, cellAnchorNodeCoordinatesDoubleArray2D, ch);
            mobileNodeCoordinate2D = new Coordinate2D(mobileNodePosition2D[0][0], mobileNodePosition2D[1][0]);

            double x = mobileNodeCoordinate2D.getX();
            double y = mobileNodeCoordinate2D.getY();

            // 3] Register the position in the mapPanel of mobileNode
            if (mapPanel.mobileNode2D == null)
            {
                mapPanel.mobileNode2D = new Node();
            }
            mapPanel.mobileNode2D.setNodeId(pMobileNode.getNodeId());
            mapPanel.mobileNode2D.setX(x);
            mapPanel.mobileNode2D.setY(y);

            // 4] Save the path of the mobile node
            Node tracedMobileNode = new Node(pMobileNode.getNodeId(), x, y, Double.NaN);
            long elapsedTime = System.currentTimeMillis() - startTime;
            if ((elapsedTime > delayTrace) && ((ekf2D.getTimeStep() * AUDIT_TIME) % sampleTrace == 0))
            {
                   mapPanel.tracedMobileNode2DFiltered.addElement(tracedMobileNode);
            }
            mapPanel.tracedMobileNode2D.addElement(tracedMobileNode);
            
            // 5] Show the position to the user
            BigDecimal BDApprox;
            BDApprox = new BigDecimal(x);
            x = BDApprox.setScale(FIX_SCALE_POINT, BigDecimal.ROUND_HALF_UP).doubleValue();
            BDApprox = new BigDecimal(y);
            y = BDApprox.setScale(FIX_SCALE_POINT, BigDecimal.ROUND_HALF_UP).doubleValue();

            xTextLabel.setText(Double.toString(x));
            yTextLabel.setText(Double.toString(y));

            // 6] Delete the elements of the vectors used for the current estimation
            cellAnchorNodeCoordinatesVector2D.clear();
            cellAnchorNodeRssVector.clear();

            //long end = System.currentTimeMillis();
            //long time = end - begin;
            //printOut("Estimation time: " + time + " [ms]", false);

            oneMsgIsArrivedAfterEstimation = false;

            estimating = false;
        }

        public boolean isEstimating()
        {
            return estimating;
        }
    }

    /**
     * Saves the traced positions to a file.
     */
    private void dataLogging(File chooserDir)
    {
        try
        {
            // 1] Open file
            //String osname = System.getProperty("os.name");
            //if (osname.equalsIgnoreCase("Linux")) {} 
            //else //if (osname.equalsIgnoreCase("Windows")) {}
            Calendar cal = Calendar.getInstance();
            SimpleDateFormat sdf = new SimpleDateFormat("dd_MM_yy-HHmm");
            String dataLogFile;

            dataLogFile = "/Teseo_" + sdf.format(cal.getTime()) + ".txt";

            FileOutputStream outputFile = new FileOutputStream(chooserDir + dataLogFile);
            PrintStream output = new PrintStream(outputFile);
            output.println("##File generated by Teseo " + version);
            output.println("");
            output.println("Start time: " + startTime + " [ms]");
            output.println("Mobile Node ID: " + idTextLabel.getText());
            output.println("");


            // 2] Write to file 2D position
            if (mapPanel.tracedMobileNode2D.size() != ZERO)
            {
                output.println("[X (m)]\t[Y (m)]");
                output.println("");

                Node mobileNode;
                Enumeration e = mapPanel.tracedMobileNode2D.elements();
                while (e.hasMoreElements())
                {
                    mobileNode = (Node) e.nextElement();
                    double posX = mobileNode.getX();
                    double posY = mobileNode.getY();
                    output.println(posX + "\t" + posY);
                }
            }
            else
            {
                output.println("No 2D positions traced.");
                output.println("");
            }

            // 3] Close file
            output.close();
            printOut("Data successfully saved to " + chooserDir + dataLogFile + '.', false);
        } catch (Exception e)
        {
            printOut("dataLogging(): " + e.toString(), true);
        }
    }

    /*****************************************************************************/
    /********************* BEGIN CODE GENERATED BY NETBEANS **********************/
    /*****************************************************************************/
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        aboutDialog = new javax.swing.JDialog();
        aboutPanel = new javax.swing.JPanel();
        aboutLabel2 = new javax.swing.JLabel();
        aboutScrollPane = new javax.swing.JScrollPane();
        aboutTextArea = new javax.swing.JTextArea();
        aboutLabel1 = new javax.swing.JLabel();
        aboutLabel3 = new javax.swing.JLabel();
        channelDialog = new javax.swing.JDialog();
        channelPanel = new javax.swing.JPanel();
        aLabel = new javax.swing.JLabel();
        npLabel = new javax.swing.JLabel();
        aTextField = new javax.swing.JTextField();
        npTextField = new javax.swing.JTextField();
        chApplyButton = new javax.swing.JButton();
        vsiDialog = new javax.swing.JDialog();
        vsiPanel = new javax.swing.JPanel();
        vsiScrollPane = new javax.swing.JScrollPane();
        vsiTextArea = new javax.swing.JTextArea();
        loggingDirChooser = new javax.swing.JFileChooser();
        traceDialog = new javax.swing.JDialog();
        tracePanel = new javax.swing.JPanel();
        delayLabel = new javax.swing.JLabel();
        sampleLabel = new javax.swing.JLabel();
        traceApplyButton = new javax.swing.JButton();
        delaySpinner = new javax.swing.JSpinner();
        sampleSpinner = new javax.swing.JSpinner();
        delayMsLabel = new javax.swing.JLabel();
        sampleMsLabel = new javax.swing.JLabel();
        mapPanelBlank = new MapPanel();
        startButton = new javax.swing.JButton();
        stopButton = new javax.swing.JButton();
        portLabel = new javax.swing.JLabel();
        PortText = new javax.swing.JTextField();
        infoPanel = new javax.swing.JPanel();
        mLabel2 = new javax.swing.JLabel();
        yTextLabel = new javax.swing.JLabel();
        yLabel = new javax.swing.JLabel();
        mLabel1 = new javax.swing.JLabel();
        xTextLabel = new javax.swing.JLabel();
        xLabel = new javax.swing.JLabel();
        idTextLabel = new javax.swing.JLabel();
        idLabel = new javax.swing.JLabel();
        bcTextLabel = new javax.swing.JLabel();
        bcLabel = new javax.swing.JLabel();
        traceToggleButton = new javax.swing.JToggleButton();
        MenuBar = new javax.swing.JMenuBar();
        fileMenu = new javax.swing.JMenu();
        saveMenuItem = new javax.swing.JMenuItem();
        viewMenu = new javax.swing.JMenu();
        vsiMenuItem = new javax.swing.JCheckBoxMenuItem();
        viewSeparator = new javax.swing.JSeparator();
        beaconsMenuItem = new javax.swing.JCheckBoxMenuItem();
        settingsMenu = new javax.swing.JMenu();
        channelMenuItem = new javax.swing.JMenuItem();
        settingsSeparator1 = new javax.swing.JSeparator();
        traceMenuItem = new javax.swing.JMenuItem();
        aboutMenu = new javax.swing.JMenu();
        aboutMenuItem = new javax.swing.JMenuItem();

        aboutDialog.setTitle("About");
        aboutDialog.setAlwaysOnTop(true);
        aboutDialog.setBackground(new java.awt.Color(0, 0, 0));
        aboutDialog.setLocationByPlatform(true);
        aboutDialog.setResizable(false);
        aboutDialog.setUndecorated(true);
        aboutDialog.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                aboutDialogMouseClicked(evt);
            }
        });
        aboutDialog.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                aboutDialogKeyPressed(evt);
            }
        });

        aboutPanel.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));

        aboutLabel2.setText("CarLOT (LOcalization and Tracking) working group.");

        aboutTextArea.setBackground(new java.awt.Color(1, 1, 1));
        aboutTextArea.setColumns(20);
        aboutTextArea.setEditable(false);
        aboutTextArea.setFont(new java.awt.Font("DejaVu Sans", 0, 12));
        aboutTextArea.setForeground(new java.awt.Color(254, 254, 254));
        aboutTextArea.setLineWrap(true);
        aboutTextArea.setRows(8);
        aboutTextArea.setText("CarLOT (LOcalization and Tracking) deals with the design and evaluation of localization and tracking techniques for wireless sensor networks. \nThe group is currently working toward the creation of a portable platform for context-rich movement tracking that will eventually be used for graphics-aided building navigation and contextualized visualization of environmental data.");
        aboutTextArea.setWrapStyleWord(true);
        aboutTextArea.setFocusable(false);
        aboutScrollPane.setViewportView(aboutTextArea);

        aboutLabel1.setText("WISE-WAI - A CaRiPaRo funded project.");

        aboutLabel3.setText("Developed by Filippo Zanella (2007 -2008).");

        org.jdesktop.layout.GroupLayout aboutPanelLayout = new org.jdesktop.layout.GroupLayout(aboutPanel);
        aboutPanel.setLayout(aboutPanelLayout);
        aboutPanelLayout.setHorizontalGroup(
            aboutPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(aboutPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(aboutPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(aboutPanelLayout.createSequentialGroup()
                        .add(aboutScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 401, Short.MAX_VALUE)
                        .addContainerGap())
                    .add(aboutPanelLayout.createSequentialGroup()
                        .add(aboutLabel2)
                        .addContainerGap(94, Short.MAX_VALUE))
                    .add(aboutPanelLayout.createSequentialGroup()
                        .add(aboutLabel1)
                        .addContainerGap(166, Short.MAX_VALUE))
                    .add(aboutPanelLayout.createSequentialGroup()
                        .add(aboutLabel3)
                        .addContainerGap(139, Short.MAX_VALUE))))
        );
        aboutPanelLayout.setVerticalGroup(
            aboutPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(aboutPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(aboutLabel1)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(aboutLabel2)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(aboutScrollPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(24, 24, 24)
                .add(aboutLabel3)
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        org.jdesktop.layout.GroupLayout aboutDialogLayout = new org.jdesktop.layout.GroupLayout(aboutDialog.getContentPane());
        aboutDialog.getContentPane().setLayout(aboutDialogLayout);
        aboutDialogLayout.setHorizontalGroup(
            aboutDialogLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(aboutPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        aboutDialogLayout.setVerticalGroup(
            aboutDialogLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(aboutDialogLayout.createSequentialGroup()
                .addContainerGap(177, Short.MAX_VALUE)
                .add(aboutPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
        );

        channelDialog.setTitle("Channel");
        channelDialog.setAlwaysOnTop(true);
        channelDialog.setLocationByPlatform(true);
        channelDialog.setMinimumSize(new java.awt.Dimension(135, 160));
        channelDialog.setResizable(false);
        channelDialog.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                channelDialogWindowClosing(evt);
            }
        });

        channelPanel.setMaximumSize(new java.awt.Dimension(135, 160));
        channelPanel.setMinimumSize(new java.awt.Dimension(135, 160));
        channelPanel.setPreferredSize(new java.awt.Dimension(135, 160));

        aLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        aLabel.setText("Beta:");

        npLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        npLabel.setText("Gamma:");

        aTextField.setText("0");

        npTextField.setText("0");

        chApplyButton.setText("Apply");
        chApplyButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                chApplyButtonActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout channelPanelLayout = new org.jdesktop.layout.GroupLayout(channelPanel);
        channelPanel.setLayout(channelPanelLayout);
        channelPanelLayout.setHorizontalGroup(
            channelPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(channelPanelLayout.createSequentialGroup()
                .add(channelPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(channelPanelLayout.createSequentialGroup()
                        .add(channelPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(channelPanelLayout.createSequentialGroup()
                                .add(31, 31, 31)
                                .add(aLabel))
                            .add(channelPanelLayout.createSequentialGroup()
                                .addContainerGap()
                                .add(npLabel)))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(channelPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(npTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 57, Short.MAX_VALUE)
                            .add(aTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 57, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                    .add(channelPanelLayout.createSequentialGroup()
                        .add(23, 23, 23)
                        .add(chApplyButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 88, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        channelPanelLayout.setVerticalGroup(
            channelPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(channelPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(channelPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(aTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(aLabel))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(channelPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(npTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(npLabel))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(chApplyButton)
                .addContainerGap(77, Short.MAX_VALUE))
        );

        org.jdesktop.layout.GroupLayout channelDialogLayout = new org.jdesktop.layout.GroupLayout(channelDialog.getContentPane());
        channelDialog.getContentPane().setLayout(channelDialogLayout);
        channelDialogLayout.setHorizontalGroup(
            channelDialogLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(channelDialogLayout.createSequentialGroup()
                .add(channelPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        channelDialogLayout.setVerticalGroup(
            channelDialogLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(channelPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 190, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
        );

        vsiDialog.setTitle("Verbose System Information");
        vsiDialog.setMinimumSize(new java.awt.Dimension(420, 476));
        vsiDialog.setName("dialog3"); // NOI18N
        vsiDialog.setResizable(false);
        vsiDialog.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                vsiDialogWindowClosing(evt);
            }
        });

        vsiPanel.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        vsiPanel.setMaximumSize(new java.awt.Dimension(420, 450));
        vsiPanel.setMinimumSize(new java.awt.Dimension(420, 450));
        vsiPanel.setPreferredSize(new java.awt.Dimension(420, 450));

        vsiScrollPane.setMaximumSize(null);
        vsiScrollPane.setMinimumSize(new java.awt.Dimension(416, 448));
        vsiScrollPane.setPreferredSize(new java.awt.Dimension(416, 448));

        vsiTextArea.setColumns(30);
        vsiTextArea.setRows(5);
        vsiTextArea.setTabSize(2);
        vsiTextArea.setMaximumSize(null);
        vsiTextArea.setMinimumSize(null);
        vsiTextArea.setRequestFocusEnabled(false);
        vsiScrollPane.setViewportView(vsiTextArea);

        org.jdesktop.layout.GroupLayout vsiPanelLayout = new org.jdesktop.layout.GroupLayout(vsiPanel);
        vsiPanel.setLayout(vsiPanelLayout);
        vsiPanelLayout.setHorizontalGroup(
            vsiPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(vsiPanelLayout.createSequentialGroup()
                .add(vsiScrollPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 416, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        vsiPanelLayout.setVerticalGroup(
            vsiPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(vsiPanelLayout.createSequentialGroup()
                .add(vsiScrollPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        org.jdesktop.layout.GroupLayout vsiDialogLayout = new org.jdesktop.layout.GroupLayout(vsiDialog.getContentPane());
        vsiDialog.getContentPane().setLayout(vsiDialogLayout);
        vsiDialogLayout.setHorizontalGroup(
            vsiDialogLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(vsiPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
        );
        vsiDialogLayout.setVerticalGroup(
            vsiDialogLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(vsiDialogLayout.createSequentialGroup()
                .add(vsiPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(29, Short.MAX_VALUE))
        );

        loggingDirChooser.setAcceptAllFileFilterUsed(false);
        loggingDirChooser.setCurrentDirectory(new java.io.File("/home/r4m/null"));
        loggingDirChooser.setDialogType(javax.swing.JFileChooser.SAVE_DIALOG);
        loggingDirChooser.setFileSelectionMode(javax.swing.JFileChooser.DIRECTORIES_ONLY);

        traceDialog.setTitle("Trace");
        traceDialog.setAlwaysOnTop(true);
        traceDialog.setLocationByPlatform(true);
        traceDialog.setMinimumSize(new java.awt.Dimension(215, 150));
        traceDialog.setResizable(false);
        traceDialog.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                traceDialogWindowClosing(evt);
            }
        });

        tracePanel.setMaximumSize(null);

        delayLabel.setText("Delay:");

        sampleLabel.setText("Sampling:");

        traceApplyButton.setText("Apply");
        traceApplyButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                traceApplyButtonActionPerformed(evt);
            }
        });

        delaySpinner.setMaximumSize(new java.awt.Dimension(73, 28));
        delaySpinner.setMinimumSize(new java.awt.Dimension(73, 28));
        delaySpinner.setPreferredSize(new java.awt.Dimension(73, 28));

        sampleSpinner.setMaximumSize(new java.awt.Dimension(73, 28));
        sampleSpinner.setMinimumSize(new java.awt.Dimension(73, 28));
        sampleSpinner.setPreferredSize(new java.awt.Dimension(73, 28));

        delayMsLabel.setText("[ms]");

        sampleMsLabel.setText("[ms]");

        org.jdesktop.layout.GroupLayout tracePanelLayout = new org.jdesktop.layout.GroupLayout(tracePanel);
        tracePanel.setLayout(tracePanelLayout);
        tracePanelLayout.setHorizontalGroup(
            tracePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(tracePanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(tracePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(traceApplyButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 109, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(tracePanelLayout.createSequentialGroup()
                        .add(tracePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                            .add(sampleLabel)
                            .add(delayLabel))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(tracePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                            .add(sampleSpinner, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .add(delaySpinner, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 73, Short.MAX_VALUE))))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(tracePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(delayMsLabel)
                    .add(sampleMsLabel))
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        tracePanelLayout.setVerticalGroup(
            tracePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(tracePanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(tracePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(delayLabel)
                    .add(delayMsLabel)
                    .add(delaySpinner, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(tracePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(sampleLabel)
                    .add(sampleMsLabel)
                    .add(sampleSpinner, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(traceApplyButton)
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        org.jdesktop.layout.GroupLayout traceDialogLayout = new org.jdesktop.layout.GroupLayout(traceDialog.getContentPane());
        traceDialog.getContentPane().setLayout(traceDialogLayout);
        traceDialogLayout.setHorizontalGroup(
            traceDialogLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(tracePanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
        );
        traceDialogLayout.setVerticalGroup(
            traceDialogLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(tracePanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
        );

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Teseo");
        setLocationByPlatform(true);
        setName("mainFrame"); // NOI18N
        setResizable(false);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        mapPanelBlank.setBackground(new java.awt.Color(254, 254, 254));
        mapPanelBlank.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(57, 119, 182)));
        mapPanelBlank.setForeground(new java.awt.Color(1, 1, 1));
        mapPanelBlank.setMaximumSize(new java.awt.Dimension(640, 480));
        mapPanelBlank.setMinimumSize(new java.awt.Dimension(640, 480));
        mapPanelBlank.setPreferredSize(new java.awt.Dimension(640, 480));

        org.jdesktop.layout.GroupLayout mapPanelBlankLayout = new org.jdesktop.layout.GroupLayout(mapPanelBlank);
        mapPanelBlank.setLayout(mapPanelBlankLayout);
        mapPanelBlankLayout.setHorizontalGroup(
            mapPanelBlankLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 644, Short.MAX_VALUE)
        );
        mapPanelBlankLayout.setVerticalGroup(
            mapPanelBlankLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 478, Short.MAX_VALUE)
        );

        startButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/teseo/img/Ok.gif"))); // NOI18N
        startButton.setText("Start");
        startButton.setMaximumSize(new java.awt.Dimension(85, 30));
        startButton.setMinimumSize(new java.awt.Dimension(85, 30));
        startButton.setMultiClickThreshhold(1000L);
        startButton.setName(""); // NOI18N
        startButton.setPreferredSize(new java.awt.Dimension(85, 30));
        startButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startButtonActionPerformed(evt);
            }
        });

        stopButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/teseo/img/Cancel.gif"))); // NOI18N
        stopButton.setText("Stop");
        stopButton.setMaximumSize(new java.awt.Dimension(85, 30));
        stopButton.setMinimumSize(new java.awt.Dimension(85, 30));
        stopButton.setMultiClickThreshhold(1000L);
        stopButton.setName(""); // NOI18N
        stopButton.setPreferredSize(new java.awt.Dimension(85, 30));
        stopButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stopButtonActionPerformed(evt);
            }
        });

        portLabel.setFont(new java.awt.Font("Dialog", 1, 12));
        portLabel.setText("COM Port:");

        PortText.setFont(new java.awt.Font("SansSerif", 0, 11));
        PortText.setMaximumSize(new java.awt.Dimension(130, 20));
        PortText.setMinimumSize(new java.awt.Dimension(130, 20));
        PortText.setPreferredSize(new java.awt.Dimension(130, 20));

        mLabel2.setText("[m]");
        mLabel2.setFocusable(false);
        mLabel2.setMaximumSize(new java.awt.Dimension(15, 15));
        mLabel2.setMinimumSize(new java.awt.Dimension(15, 15));
        mLabel2.setPreferredSize(new java.awt.Dimension(15, 15));

        yTextLabel.setFocusable(false);
        yTextLabel.setMaximumSize(new java.awt.Dimension(50, 15));
        yTextLabel.setMinimumSize(new java.awt.Dimension(50, 15));
        yTextLabel.setPreferredSize(new java.awt.Dimension(50, 15));

        yLabel.setText("Y:");
        yLabel.setFocusable(false);
        yLabel.setMaximumSize(new java.awt.Dimension(15, 15));
        yLabel.setMinimumSize(new java.awt.Dimension(15, 15));
        yLabel.setPreferredSize(new java.awt.Dimension(15, 15));

        mLabel1.setText("[m]");
        mLabel1.setFocusable(false);
        mLabel1.setMaximumSize(new java.awt.Dimension(15, 15));
        mLabel1.setMinimumSize(new java.awt.Dimension(15, 15));
        mLabel1.setPreferredSize(new java.awt.Dimension(15, 15));

        xTextLabel.setFocusable(false);
        xTextLabel.setMaximumSize(new java.awt.Dimension(50, 15));
        xTextLabel.setMinimumSize(new java.awt.Dimension(50, 15));
        xTextLabel.setPreferredSize(new java.awt.Dimension(50, 15));

        xLabel.setText("X:");
        xLabel.setFocusable(false);
        xLabel.setMaximumSize(new java.awt.Dimension(15, 15));
        xLabel.setMinimumSize(new java.awt.Dimension(15, 15));
        xLabel.setPreferredSize(new java.awt.Dimension(15, 15));

        idTextLabel.setText("0");
        idTextLabel.setFocusable(false);
        idTextLabel.setMaximumSize(new java.awt.Dimension(45, 15));
        idTextLabel.setMinimumSize(new java.awt.Dimension(45, 15));
        idTextLabel.setPreferredSize(new java.awt.Dimension(45, 15));

        idLabel.setText("ID:");
        idLabel.setFocusable(false);

        bcTextLabel.setText("0");
        bcTextLabel.setFocusable(false);
        bcTextLabel.setMaximumSize(new java.awt.Dimension(45, 15));
        bcTextLabel.setMinimumSize(new java.awt.Dimension(45, 15));
        bcTextLabel.setPreferredSize(new java.awt.Dimension(45, 15));

        bcLabel.setText("#Step:");
        bcLabel.setFocusable(false);

        traceToggleButton.setText("Trace Path");
        traceToggleButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                traceToggleButtonActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout infoPanelLayout = new org.jdesktop.layout.GroupLayout(infoPanel);
        infoPanel.setLayout(infoPanelLayout);
        infoPanelLayout.setHorizontalGroup(
            infoPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(infoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(bcLabel)
                .add(11, 11, 11)
                .add(bcTextLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(idLabel)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(idTextLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 32, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 77, Short.MAX_VALUE)
                .add(xLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(xTextLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 50, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(mLabel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 25, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(40, 40, 40)
                .add(yLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(yTextLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 50, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(mLabel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 25, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(47, 47, 47)
                .add(traceToggleButton)
                .add(24, 24, 24))
        );
        infoPanelLayout.setVerticalGroup(
            infoPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(infoPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                .add(mLabel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 23, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(mLabel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 23, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(yLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 23, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(xLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 23, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(idTextLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 23, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(idLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 23, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(bcTextLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 23, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(bcLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 23, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .add(traceToggleButton, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(yTextLabel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 29, Short.MAX_VALUE)
            .add(xTextLabel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 29, Short.MAX_VALUE)
        );

        fileMenu.setText("File");

        saveMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        saveMenuItem.setText("Save");
        saveMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(saveMenuItem);

        MenuBar.add(fileMenu);

        viewMenu.setBorder(null);
        viewMenu.setText("View");

        vsiMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_V, java.awt.event.InputEvent.ALT_MASK));
        vsiMenuItem.setSelected(true);
        vsiMenuItem.setText("VSI");
        vsiMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                vsiMenuItemActionPerformed(evt);
            }
        });
        viewMenu.add(vsiMenuItem);
        viewMenu.add(viewSeparator);

        beaconsMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_B, java.awt.event.InputEvent.ALT_MASK));
        beaconsMenuItem.setSelected(true);
        beaconsMenuItem.setText("Beacons");
        beaconsMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                beaconsMenuItemActionPerformed(evt);
            }
        });
        viewMenu.add(beaconsMenuItem);

        MenuBar.add(viewMenu);

        settingsMenu.setBorder(null);
        settingsMenu.setText("Settings");

        channelMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_C, java.awt.event.InputEvent.CTRL_MASK));
        channelMenuItem.setText("Channel");
        channelMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                channelMenuItemActionPerformed(evt);
            }
        });
        settingsMenu.add(channelMenuItem);
        settingsMenu.add(settingsSeparator1);

        traceMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_T, java.awt.event.InputEvent.CTRL_MASK));
        traceMenuItem.setText("Trace");
        traceMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                traceMenuItemActionPerformed(evt);
            }
        });
        settingsMenu.add(traceMenuItem);

        MenuBar.add(settingsMenu);

        aboutMenu.setBorder(null);
        aboutMenu.setText("?");

        aboutMenuItem.setText("About");
        aboutMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                aboutMenuItemActionPerformed(evt);
            }
        });
        aboutMenu.add(aboutMenuItem);

        MenuBar.add(aboutMenu);

        setJMenuBar(MenuBar);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, infoPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, layout.createSequentialGroup()
                        .add(startButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 85, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                        .add(stopButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 85, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(43, 43, 43)
                        .add(portLabel)
                        .add(3, 3, 3)
                        .add(PortText, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 162, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(org.jdesktop.layout.GroupLayout.LEADING, mapPanelBlank, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 646, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(startButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 30, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(stopButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 30, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(portLabel)
                    .add(PortText, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 20, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(mapPanelBlank, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(infoPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width-674)/2, (screenSize.height-620)/2, 674, 620);
    }// </editor-fold>//GEN-END:initComponents

   private void aboutMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_aboutMenuItemActionPerformed
       if (about != null)
       {
           aboutDialog.remove(about);
       }
       aboutPanel.setVisible(true);
       about = new About("img/ww_logo.jpg", 425, 155);
       int txtSpace = 230; //[pxl]
       aboutDialog.setSize(about.getWidth(), about.getHeight() + txtSpace);
       int jD1x = this.getX() + (int) (this.getWidth() - aboutDialog.getWidth()) / 2;
       int jD1y = this.getY() + (int) (this.getHeight() - aboutDialog.getHeight()) / 2;
       aboutDialog.setLocation(jD1x, jD1y);
       aboutDialog.add(about);
       SwingUtilities.updateComponentTreeUI(channelDialog);
       aboutDialog.setVisible(true);
       about.repaint();
}//GEN-LAST:event_aboutMenuItemActionPerformed

    private void aboutDialogKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_aboutDialogKeyPressed
        if (evt.getKeyCode() == KeyEvent.VK_W && evt.isControlDown())
        {
            aboutDialog.remove(about);
            aboutPanel.setVisible(false);
            about = new About("img/wig_logo.jpg", 425, 310);
            aboutDialog.setSize(about.getWidth(), about.getHeight());
            int jD1x = this.getX() + (int) (this.getWidth() - aboutDialog.getWidth()) / 2;
            int jD1y = this.getY() + (int) (this.getHeight() - aboutDialog.getHeight()) / 2;
            aboutDialog.setLocation(jD1x, jD1y);
            aboutDialog.add(about);
            about.repaint();
            printOut("||- Tribute to WedgeITGroup -||", false);
        }
}//GEN-LAST:event_aboutDialogKeyPressed

    private void aboutDialogMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_aboutDialogMouseClicked
        SwingUtilities.updateComponentTreeUI(channelDialog);
        aboutDialog.setVisible(false);
}//GEN-LAST:event_aboutDialogMouseClicked

    /** 
     * Stops the localitation routines.
     *
     * @param evt   event which indicates that the user pushed the "STOP" button       
     */
    private void stopButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stopButtonActionPerformed
        stop();
    }//GEN-LAST:event_stopButtonActionPerformed

    /** 
     * Starts the localitation routines.
     *
     * @param evt   event which indicates that the user pushed the "START" button       
     */
    private void startButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startButtonActionPerformed
        start();
    }//GEN-LAST:event_startButtonActionPerformed

    /** 
     * Closes the GUI.
     *
     * @param evt   event which indicates that the user pushed the "X" button       
     */
    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        printOut("Query: Teseo closing.", false);
        stop();
    }//GEN-LAST:event_formWindowClosing

    /** 
     * Sets the parameters of the channel model choiced by the user.
     *
     * @param evt   event which indicates that the user pushed the "APPLY" button       
     */
    private void chApplyButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chApplyButtonActionPerformed
        try
        {
            ch.setChannel(Double.parseDouble(aTextField.getText()), Double.parseDouble(npTextField.getText()));
            printOut("Channel configuration:" + " Beta = " + ch.getBeta() + " [dBm]" + "  Gamma = " + ch.getGamma(), false);
            this.setEnabled(true);
            channelDialog.setVisible(false);
        } catch (NumberFormatException e)
        {
            JOptionPane.showMessageDialog(channelDialog,
                    "Insert a valid number.",
                    "NumberFormatException",
                    JOptionPane.ERROR_MESSAGE);         
        }
}//GEN-LAST:event_chApplyButtonActionPerformed

private void vsiMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_vsiMenuItemActionPerformed
    SwingUtilities.updateComponentTreeUI(vsiDialog);
    vsiDialog.setVisible(vsiMenuItem.isSelected());
//printOut("VSI: " + vsiDialog.isVisible(), false);
}//GEN-LAST:event_vsiMenuItemActionPerformed

private void channelDialogWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_channelDialogWindowClosing
    this.setEnabled(true);
}//GEN-LAST:event_channelDialogWindowClosing

private void vsiDialogWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_vsiDialogWindowClosing
    vsiMenuItem.setSelected(false);
}//GEN-LAST:event_vsiDialogWindowClosing

private void saveMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveMenuItemActionPerformed
    //SwingUtilities.updateComponentTreeUI(loggingDirChooser);
    if (loggingDirChooser.showSaveDialog(this) == loggingDirChooser.APPROVE_OPTION)
    {
        dataLogging(loggingDirChooser.getSelectedFile());
    }
}//GEN-LAST:event_saveMenuItemActionPerformed

private void traceToggleButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_traceToggleButtonActionPerformed
    mapPanel.setTraceTracking(traceToggleButton.isSelected());
    printOut("Trace tracking: " + traceToggleButton.isSelected(), false);
}//GEN-LAST:event_traceToggleButtonActionPerformed

private void channelMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_channelMenuItemActionPerformed
    int jD1x = this.getX() + (int) (this.getWidth() - channelDialog.getWidth()) / 2;
    int jD1y = this.getY() + (int) (this.getHeight() - channelDialog.getHeight()) / 2;
    channelDialog.setLocation(jD1x, jD1y);
    SwingUtilities.updateComponentTreeUI(channelDialog);
    this.setEnabled(false);
    channelDialog.setVisible(true);
}//GEN-LAST:event_channelMenuItemActionPerformed

private void traceMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_traceMenuItemActionPerformed
    int jD1x = this.getX() + (int) (this.getWidth() - traceDialog.getWidth()) / 2;
    int jD1y = this.getY() + (int) (this.getHeight() - traceDialog.getHeight()) / 2;
    traceDialog.setLocation(jD1x, jD1y);
    SwingUtilities.updateComponentTreeUI(traceDialog);
    this.setEnabled(false);
    traceDialog.setVisible(true);
}//GEN-LAST:event_traceMenuItemActionPerformed

private void traceDialogWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_traceDialogWindowClosing
    this.setEnabled(true);
}//GEN-LAST:event_traceDialogWindowClosing

private void traceApplyButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_traceApplyButtonActionPerformed
    delayTrace = Long.valueOf(delaySpinner.getValue().toString());
    sampleTrace = Long.valueOf(sampleSpinner.getValue().toString());
    printOut("Trace path: " + " delay " + delayTrace + " [ms]" + "\t sampling " + sampleTrace + " [ms] ", false);
    this.setEnabled(true);
    traceDialog.setVisible(false);
}//GEN-LAST:event_traceApplyButtonActionPerformed


private void beaconsMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_beaconsMenuItemActionPerformed
    mapPanel.setShowBeacons(beaconsMenuItem.isSelected());
}//GEN-LAST:event_beaconsMenuItemActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuBar MenuBar;
    private javax.swing.JTextField PortText;
    private javax.swing.JLabel aLabel;
    private javax.swing.JTextField aTextField;
    private javax.swing.JDialog aboutDialog;
    private javax.swing.JLabel aboutLabel1;
    private javax.swing.JLabel aboutLabel2;
    private javax.swing.JLabel aboutLabel3;
    private javax.swing.JMenu aboutMenu;
    private javax.swing.JMenuItem aboutMenuItem;
    private javax.swing.JPanel aboutPanel;
    private javax.swing.JScrollPane aboutScrollPane;
    private javax.swing.JTextArea aboutTextArea;
    private javax.swing.JLabel bcLabel;
    private javax.swing.JLabel bcTextLabel;
    private javax.swing.JCheckBoxMenuItem beaconsMenuItem;
    private javax.swing.JButton chApplyButton;
    private javax.swing.JDialog channelDialog;
    private javax.swing.JMenuItem channelMenuItem;
    private javax.swing.JPanel channelPanel;
    private javax.swing.JLabel delayLabel;
    private javax.swing.JLabel delayMsLabel;
    private javax.swing.JSpinner delaySpinner;
    private javax.swing.JMenu fileMenu;
    private javax.swing.JLabel idLabel;
    private javax.swing.JLabel idTextLabel;
    private javax.swing.JPanel infoPanel;
    private javax.swing.JFileChooser loggingDirChooser;
    private javax.swing.JLabel mLabel1;
    private javax.swing.JLabel mLabel2;
    private javax.swing.JPanel mapPanelBlank;
    private javax.swing.JLabel npLabel;
    private javax.swing.JTextField npTextField;
    private javax.swing.JLabel portLabel;
    private javax.swing.JLabel sampleLabel;
    private javax.swing.JLabel sampleMsLabel;
    private javax.swing.JSpinner sampleSpinner;
    private javax.swing.JMenuItem saveMenuItem;
    private javax.swing.JMenu settingsMenu;
    private javax.swing.JSeparator settingsSeparator1;
    private javax.swing.JButton startButton;
    private javax.swing.JButton stopButton;
    private javax.swing.JButton traceApplyButton;
    private javax.swing.JDialog traceDialog;
    private javax.swing.JMenuItem traceMenuItem;
    private javax.swing.JPanel tracePanel;
    private javax.swing.JToggleButton traceToggleButton;
    private javax.swing.JMenu viewMenu;
    private javax.swing.JSeparator viewSeparator;
    private javax.swing.JDialog vsiDialog;
    private javax.swing.JCheckBoxMenuItem vsiMenuItem;
    private javax.swing.JPanel vsiPanel;
    private javax.swing.JScrollPane vsiScrollPane;
    private javax.swing.JTextArea vsiTextArea;
    private javax.swing.JLabel xLabel;
    private javax.swing.JLabel xTextLabel;
    private javax.swing.JLabel yLabel;
    private javax.swing.JLabel yTextLabel;
    // End of variables declaration//GEN-END:variables
    /*****************************************************************************/
    /*********************** END CODE GENERATED BY NETBEANS **********************/
    /*****************************************************************************/
    /** 
     * Constructs the main class {@link Teseo} displaying the splash screen.
     * It also sets the appropriate look and feel for the current OS.
     *
     * @param args      command line arguments       
     */
    public static void main(String args[])
    {
//        System.out.println("LookAndFeel: " + UIManager.getLookAndFeel().getName());
//        for (int i = 0; i < UIManager.getInstalledLookAndFeels().length; i++)
//        {
//            System.out.println("InstalledLookAndFeels: " + UIManager.getInstalledLookAndFeels()[i].getName());
//        }

        // VM Options: -splash:build/classes/teseo/img/splash.jpg
        final SplashScreen splscr = SplashScreen.getSplashScreen();

        if (splscr == null)
        {
            //tmpTeseo.printOut("main(): SplashScreen not instantiated.", true);
        }
        else
        {
            Graphics2D g = (Graphics2D) splscr.createGraphics();
            if (g == null)
            {
                //tmpTeseo.printOut("main(): Graphics2D is NULL.", true);
            }
            else
            {
                g.setColor(Color.WHITE);
                g.setFont(new Font(Font.DIALOG, Font.PLAIN, 15));
                String title = "Teseo " + Teseo.version;
                g.drawString(title, 50, 40);
                g.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));
                String info1 = COPYRIGHT + "Copyright of WISE-WAI - A CaRiPaRo funded project.";
                String info2 = "CarLOT (LOcalization and Tracking) working group.";
                g.drawString(info1, 50, 120);
                g.drawString(info2, 50, 135);
                splscr.update();

                g.setComposite(AlphaComposite.Clear);
                g.setPaintMode();
                g.setColor(GREEN_2);
                for (int i = 0; i < 200;)
                {
                    g.fillRect(100 + i, 160, 10, 10);
                    splscr.update();
                    i = i + 12;
                    try
                    {
                        Thread.sleep(100);
                    } catch (InterruptedException e)
                    {
                    }
                }
            }
            try{Thread.sleep(500);} catch (InterruptedException e) {}
            splscr.close();
            g.setColor(Color.BLACK);
            g.setFont(new Font(Font.DIALOG, Font.PLAIN, 11));
        }

        Teseo tmpTeseo = new Teseo();

        try
        {
            String osname = System.getProperty("os.name");
            if (osname.equalsIgnoreCase("Windows"))
            {
                UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
            }
            else if (osname.equalsIgnoreCase("Linux"))
            {
                UIManager.setLookAndFeel("com.sun.java.swing.plaf.gtk.GTKLookAndFeel");
//                UIManager.setLookAndFeel("javax.swing.plaf.metal.MetalLookAndFeel");
            }
        } catch (Exception e)
        {
            tmpTeseo.printOut("main(): " + e.toString(), true);
        }

        SwingUtilities.updateComponentTreeUI(tmpTeseo);

        //tmpTeseo.pack();  // NEVER PACK THE JFRAME BEFORE initComponents() !!!
        tmpTeseo.setVisible(true);
    }

    /**
     * Generates the software version, that is the numeric date yy.MM.dd HHmm.
     *
     * @return      the generated version
     */
    private String genVersion()
    {
        final String DATE_FORMAT_DAY = "yy.MM.dd";
        final String DATE_FORMAT_HOURS = "HHmm";
        Calendar cal = Calendar.getInstance();
        SimpleDateFormat sdfD = new SimpleDateFormat(DATE_FORMAT_DAY + "." + DATE_FORMAT_HOURS);
        return sdfD.format(cal.getTime());
    }

    /**
     * Prints a string message to the standard output and in the VSI panel.
     *
     * @param str       string to print  
     * @param isErr     whether or not the string is an error message  
     */
    public void printOut(String str, boolean isErr)
    {
        if (isErr)
        {
            System.err.println(str);
        }
        else
        {
            System.out.println(str);
        }
        vsiTextArea.append(str + '\n');
    }

    private Image loadImage(String img)
    {
        URL url = this.getClass().getResource(img);
        if (url != null)
        {
            return Toolkit.getDefaultToolkit().getImage(url);
        }
        else
        {
            printOut("loadImage(): file " + img + " not found!", false);
            return null;
        }
    }

    /*****************************************************************************/
    /******************************** ABOUT WINDOW *******************************/
    /*****************************************************************************/
    public class About extends JPanel implements Serializable
    {

        private Image logo;

        public About(String logoDir, int logoWidth, int logoHeight)
        {
            setSize(logoWidth, logoHeight);
            logo = loadImage(logoDir);
        }

        @Override
        public void paintComponent(Graphics g)
        {
            super.paintComponent(g);
            if (logo != null)
            {
                g.drawImage(logo, 0, 0, this);
            }
        }
    }

    /*****************************************************************************/
    /********************************** MAP PANEL *********************************/
    /*****************************************************************************/
    public class MapPanel extends JPanel implements Serializable, Runnable, Constants
    {

        public Map<Integer, Node> NodeMapHash = new HashMap<Integer, Node>();     // HashMap to collect all the nodes of the environment
        public Map<Integer, Node> CellNodeMapHash = new HashMap<Integer, Node>(); // HashMap to collect all the nodes of the measurements set
        public Vector<Node> tracedMobileNode2D;  // Vector to save the positions of the mobile node
        public Vector<Node> tracedMobileNode2DFiltered;  // Vector to save the positions of the mobile node
        private File currentMapFile;          // File *.map in /maps
        private Image map;                    // Image of the map stored in /img
        private int X0;                       // Position of the axis origin in [pxl], x-axes
        private int Y0;                       // Position of the axis origin in [pxl], y-axes
        private double onePxlX;               // [pxl] and [m] scale, x-axes
        private double onePxlY;               // [pxl] and [m] scale,, y-axes
        private Set NodeSet;                  // Set of ID of fixed nodes
        private Iterator NodeIterator;        
        private Image zeroPoint;              
        private Image anImgOff;               
        private Image anImgOn;               
        private Image mnImg2D;                  
        private Node mobileNode2D;            // mobile node 2D
        private boolean traceTracking;       
        private boolean showBeacons;        
        private Thread refreshMap;            // Thread per il repaint

        public MapPanel()
        {
//        System.out.println("Called MapPanel constructor");
        }

        // Init the enviroment loading the map and the nodes positions
        public void initEnvironment(String currentMap)
        {
            map = null;
            parseMapFile(currentMap);

            zeroPoint = null;
            zeroPoint = loadImage("img/ZeroPoint.gif");
            anImgOff = null;
            anImgOff = loadImage("img/AnchorNodeOff.gif");
            anImgOn = null;
            anImgOn = loadImage("img/AnchorNodeOn.gif");
            mnImg2D = null;
            mnImg2D = loadImage("img/MobileNode.gif");

            tracedMobileNode2D = new Vector<Node>();
            tracedMobileNode2DFiltered = new Vector<Node>();

            refreshMap = new Thread(this);
            refreshMap.start();
        }

        // Function to read the configuration file of the map
        private void parseMapFile(String currentMap)
        {
            int indexElement = 0;
            int raw = 0;

            try
            {
                URL url = this.getClass().getResource(currentMap);
                if (url != null)
                {
                    currentMapFile = new File(url.getFile());
                }
                else
                {
                    printOut("MapPanel.parseMapFile(): file " + currentMap + " not found! Exiting.\n", true);
                    System.exit(1);
                }

                Scanner sc = new Scanner(currentMapFile);
                while (sc.hasNextLine())
                {
                    String currentLine = sc.nextLine();

                    if ((currentLine != null) && (!currentLine.trim().equals("")))
                    {
                        if (currentLine.charAt(0) != '#')
                        {
                            raw++;
                            //System.out.println(currentLine);

                            if (raw == 1)
                            {
                                map = loadImage(currentLine);
                                printOut("  > image: " + currentLine, false);
                            }
                            if (raw == 2)
                            {
                                String x0 = "", y0 = "";
                                indexElement = 0;
                                for (int i = 0; i < currentLine.length(); i++)
                                {
                                    if (currentLine.charAt(i) != ' ')
                                    {
                                        if (indexElement == 0)
                                        {
                                            x0 = x0 + currentLine.charAt(i);
                                        }
                                        else if (indexElement == 1)
                                        {
                                            y0 = y0 + currentLine.charAt(i);
                                        }
                                    }
                                    else
                                    {
                                        indexElement++;
                                    }
                                }
                                try
                                {
                                    X0 = Integer.parseInt(x0);
                                    Y0 = Integer.parseInt(y0);
                                    printOut("  > X0 = " + X0 + " [pxl] " + "  Y0 = " + Y0 + " [pxl] ", false);
                                //System.out.println("x0: " + x0 + "\ty0: " + y0);
                                } catch (NumberFormatException e)
                                {
                                    printOut("MapPanel.parseMapFile(): " + e.toString(), true);
                                }
                            }
                            if (raw == 3)
                            {
                                String ONEPXLX = "", ONEPXLY = "";
                                indexElement = 0;
                                for (int i = 0; i < currentLine.length(); i++)
                                {
                                    if (currentLine.charAt(i) != ' ')
                                    {
                                        if (indexElement == 0)
                                        {
                                            ONEPXLX = ONEPXLX + currentLine.charAt(i);
                                        }
                                        else if (indexElement == 1)
                                        {
                                            ONEPXLY = ONEPXLY + currentLine.charAt(i);
                                        }
                                    }
                                    else
                                    {
                                        indexElement++;
                                    }
                                }
                                try
                                {
                                    onePxlX = Double.parseDouble(ONEPXLX);
                                    onePxlY = Double.parseDouble(ONEPXLY);
                                    printOut("  > X: 1 [pxl] = " + onePxlX + " [m] " + " Y: 1 [pxl] = " + onePxlY + " [m] ", false);
                                } catch (NumberFormatException e)
                                {
                                    printOut("MapPanel.parseMapFile(): " + e.toString(), true);
                                }
                            }
                            if (raw > 3)
                            {
                                String id = "", posX = "", posY = "", posZ = "";
                                indexElement = 0;
                                for (int i = 0; i < currentLine.length(); i++)
                                {
                                    if (currentLine.charAt(i) != ' ')
                                    {
                                        if (indexElement == 0)
                                        {
                                            id = id + currentLine.charAt(i);
                                        }
                                        else if (indexElement == 1)
                                        {
                                            posX = posX + currentLine.charAt(i);
                                        }
                                        else if (indexElement == 2)
                                        {
                                            posY = posY + currentLine.charAt(i);
                                        }
                                        else if (indexElement == 3)
                                        {
                                            posZ = posZ + currentLine.charAt(i);
                                        }
                                    }
                                    else
                                    {
                                        indexElement++;
                                    }
                                }
                                try
                                {
                                    int n_id = Integer.parseInt(id);
                                    double n_x = Double.parseDouble(posX);
                                    double n_y = Double.parseDouble(posY);
                                    double n_z = Double.parseDouble(posZ);
                                    //System.out.println(\tid: " + n_id
                                    // + "\tposX: " + n_x + "\tposY: " + n_y + "\tposZ: " + n_z);
                                    printOut("  > Node " + n_id + ":\tX = " + n_x + " [m]" + "\tY = " + n_y + " [m]" + "\tZ = " + n_z + " [m] ", false);

                                    if (!NodeMapHash.containsKey(n_id))
                                    {
                                        NodeMapHash.put(n_id, new Node(n_id, n_x, n_y, n_z));
                                    }
                                } catch (NumberFormatException e)
                                {
                                    printOut("MapPanel.parseMapFile(): " + e.toString(), true);
                                }
                            }
                        }
                    }
                }
                //System.out.println(NodeMapHash.keySet().toString());
                NodeSet = NodeMapHash.keySet();
                sc.close();
            } catch (NullPointerException e)
            {
                printOut("MapPanel.parseMapFile(): " + e.toString(), true);
            } catch (IOException e)
            {
                printOut("MapPanel.parseMapFile(): " + e.toString(), true);
            }
        }

        @Override
        public void paintComponent(Graphics g)
        {
            super.paintComponent(g);
            //System.out.println("Repaint MapPanel");

            if (map != null)
            {
                int height = StrictMath.round(this.getSize().height);
                int width = StrictMath.round(this.getSize().width);
                g.drawImage(map, ZERO, ZERO, width, height, this);
            }

            if (zeroPoint != null)
            {
                int height = StrictMath.round(zeroPoint.getHeight(this) / 2);
                int width = StrictMath.round(zeroPoint.getWidth(this) / 2);
                g.drawImage(zeroPoint, X0 - width, Y0 - height, this);
            }
            else
            {
                g.setColor(BROWN);
                g.fillRect(X0 - 3, Y0 - 3, 7, 7);
            }

            if (showBeacons)
            {
                NodeSet = NodeMapHash.keySet();
                NodeIterator = NodeSet.iterator();
                while (NodeIterator.hasNext())
                {
                    Node anchorNodeTmp = (Node) NodeMapHash.get(NodeIterator.next());
                    if (CellNodeMapHash.containsKey(anchorNodeTmp.getNodeId()))
                    {
                        drawAnchorNode(anchorNodeTmp, g, true);
                    }
                    else
                    {
                        drawAnchorNode(anchorNodeTmp, g, false);
                    }
                }
            }

            Vector<Node> currentTraceMobileNode;
            currentTraceMobileNode = tracedMobileNode2DFiltered;
            if (mobileNode2D != null)
                drawMobileNode(g, mobileNode2D, mnImg2D);
            

            if (currentTraceMobileNode != null)
            {
                if (traceTracking && currentTraceMobileNode.size() != ZERO)
                {

                    Enumeration e = currentTraceMobileNode.elements();
                    Node prevMN = currentTraceMobileNode.firstElement();
                    Node curMN = null;

                    if (currentTraceMobileNode.size() > MIN_TRACE_SIZE)
                    {
                        for (int i = 0; i < (currentTraceMobileNode.size() - (currentTraceMobileNode.size() / 2)); i++)
                        {
                            curMN = (Node) e.nextElement();
                            prevMN = curMN;
                        }
                        while (e.hasMoreElements())
                        {
                            curMN = (Node) e.nextElement();
                            int prevPxlX = getPxlX(prevMN.getX());
                            int prevPxlY = getPxlY(prevMN.getY());
                            int curPxlX = getPxlX(curMN.getX());
                            int curPxlY = getPxlY(curMN.getY());
                            drawThickLine(g, prevPxlX, prevPxlY, curPxlX, curPxlY, 4, Color.RED);
                            prevMN = curMN;
                        }
                    }
                    else
                    {
                        while (e.hasMoreElements())
                        {
                            curMN = (Node) e.nextElement();
                            int prevPxlX = getPxlX(prevMN.getX());
                            int prevPxlY = getPxlY(prevMN.getY());
                            int curPxlX = getPxlX(curMN.getX());
                            int curPxlY = getPxlY(curMN.getY());
                            drawThickLine(g, prevPxlX, prevPxlY, curPxlX, curPxlY, 4, Color.RED);
                            prevMN = curMN;
                        }
                    }
                }
            }
        }

        private int getPxlX(double posX)
        {
            int xPxl = (int) StrictMath.round(posX / onePxlX);
            xPxl = X0 + xPxl;
            return xPxl;
        }

        private int getPxlY(double posY)
        {
            int yPxl = (int) StrictMath.round(posY / onePxlY);
            yPxl = Y0 - yPxl;
            return yPxl;
        }

        // Funzione per disegnare un nodo ancora
        private void drawAnchorNode(Node anchorNode, Graphics g, boolean active)
        {
            int xPxl = getPxlX(anchorNode.getX());
            int yPxl = getPxlY(anchorNode.getY());

            if (anImgOn != null && anImgOff != null)
            {
                int height = StrictMath.round(anImgOn.getHeight(this) / 2);
                int width = StrictMath.round(anImgOn.getWidth(this) / 2);

                if (active)
                {
                    g.drawImage(anImgOn, xPxl - width, yPxl - height, this);
                }
                else
                {
                    g.drawImage(anImgOff, xPxl - width, yPxl - height, this);
                    //g.drawString(Integer.toString(anchorNode.getNodeId()),(xPxl - width), (yPxl - height));
                }
            }
            else
            {
                if (active)
                {
                    g.setColor(BLUE);
                    g.fillRect(xPxl - 3, yPxl - 3, 7, 7);
                }
                else
                {
                    g.setColor(RED);
                    g.fillRect(xPxl - 3, yPxl - 3, 7, 7);
                }
            }
        }

        // Funzione per disegnare il nodo mobile
        private void drawMobileNode(Graphics g, Node mobileNode, Image mnImg)
        {
            int height = StrictMath.round(mnImg.getHeight(this) / 2);
            int width = StrictMath.round(mnImg.getWidth(this) / 2);
            int xPxl = getPxlX(mobileNode.getX());
            int yPxl = getPxlY(mobileNode.getY());

            if (mnImg != null)
            {
                g.drawImage(mnImg, (xPxl - width), (yPxl - height), this);
                g.drawString(Integer.toString(mapPanel.mobileNode2D.getNodeId()),(xPxl - width), (yPxl + height/2));
            }
            else
            {
                g.setColor(GREEN);
                g.fillRect(xPxl - 4, yPxl - 4, 9, 9);
            }
        }
        // Running del thread 
        public void run()
        {
            // TODO: Mettere una variabile di controllo per terminare il task
            while (true)
            {
                try
                {
                    Thread.sleep(REFRESH_TIME);
                } catch (InterruptedException e)
                {
                    printOut("MapPanel.run(): " + e.toString(), true);
                    this.run();
                }
                repaint();
            }
        }

        public void drawThickLine(Graphics g, int x1, int y1, int x2, int y2, int thickness, Color c)
        {
            g.setColor(c);
            int dX = x2 - x1;
            int dY = y2 - y1;
            double lineLength = StrictMath.sqrt(dX * dX + dY * dY);

            double scale = (double) (thickness) / (2 * lineLength);

            double ddx = -scale * (double) dY;
            double ddy = scale * (double) dX;
            ddx += (ddx > 0) ? 0.5 : -0.5;
            ddy += (ddy > 0) ? 0.5 : -0.5;
            int dx = (int) ddx;
            int dy = (int) ddy;

            int xPoints[] = new int[4];
            int yPoints[] = new int[4];

            xPoints[0] = x1 + dx;
            yPoints[0] = y1 + dy;
            xPoints[1] = x1 - dx;
            yPoints[1] = y1 - dy;
            xPoints[2] = x2 - dx;
            yPoints[2] = y2 - dy;
            xPoints[3] = x2 + dx;
            yPoints[3] = y2 + dy;

            g.fillPolygon(xPoints, yPoints, 4);
        }

        public void setTraceTracking(boolean _traceTracking)
        {
            traceTracking = _traceTracking;
        }

        public boolean getTraceTracking()
        {
            return traceTracking;
        }

        public void setShowBeacons(boolean _showBeacons)
        {
            showBeacons = _showBeacons;
        }

        public boolean getShowBeacons()
        {
            return showBeacons;
        }
    }
}
